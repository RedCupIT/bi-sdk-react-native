{"version":3,"names":["EmbeddedNativeModules","LoggerEventEmitter","Embedded","authenticate","url","passkeyId","Promise","resolve","reject","then","response","redirectUrl","message","undefined","catch","bindPasskey","passkey","postBindingRedirectUri","deletePasskey","id","getPasskeys","initialize","biometricAskPrompt","allowedDomains","isAuthenticateUrl","isBindPasskeyUrl","logEventEmitter"],"sources":["index.tsx"],"sourcesContent":["import {\n  EmbeddedNativeModules,\n  LoggerEventEmitter,\n  BILoggerEmitter,\n} from './EmbeddedNativeModules';\n\nimport type {\n  AuthenticateResponse,\n  BindPasskeyResponse,\n  Passkey,\n  PasskeyState,\n  Success,\n} from './EmbeddedTypes';\n\ninterface Embedded {\n  /**\n   * Authenticate a user and receive an `AuthenticateResponse`.\n   * @param url the URL used to authenticate.\n   * @param passkeyId the ID of the passkey with which to authenticate.\n   */\n  authenticate(url: string, passkeyId: string): Promise<AuthenticateResponse>;\n\n  /**\n   * Bind a passkey to a device.\n   * @param url the URL used to bind a passkey to a device.\n   */\n  bindPasskey(url: string): Promise<BindPasskeyResponse>;\n\n  /**\n   * Delete a passkey by ID.\n   * @warning deleting a passkey is destructive and will remove everything from the device. If no other device contains the passkey then the user will need to complete a recovery in order to log in again on this device.\n   * @param id the the passkey id, uniquely identifying a `Passkey`.\n   */\n  deletePasskey(id: string): Promise<string>;\n\n  /**\n   * Get all current passkeys for this device.\n   */\n  getPasskeys(): Promise<Passkey[]>;\n\n  /**\n   * Initialize the SDK. This must be called before any other functions are called.\n   * Note: Hot reloading will not call this function again. If changes have been made to calling this function, fully reload the app to see those changes.\n   * @param biometricAskPrompt A prompt the user will see when asked for biometrics.\n   * @param allowedDomains An optional array of whitelisted domains for network operations. This will default to Beyond Identityâ€™s allowed domains when not provided or is empty.\n   */\n  initialize(\n    biometricAskPrompt: string,\n    allowedDomains?: string[]\n  ): Promise<Success>;\n\n  /**\n   * Returns whether a URL is a valid Authenticate URL or not.\n   * @param url The URL in question.\n   */\n  isAuthenticateUrl(url: string): Promise<boolean>;\n\n  /**\n   * Returns whether a URL is a valid Bind Passkey URL or not.\n   * @param url The URL in question.\n   */\n  isBindPasskeyUrl(url: string): Promise<boolean>;\n\n  /**\n   * A NativeEventEmitter to listen for `Logger` events after calling `Embedded.initialize`\n   */\n  logEventEmitter: BILoggerEmitter;\n}\n\nconst Embedded: Embedded = {\n  authenticate(url: string, passkeyId: string): Promise<AuthenticateResponse> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.authenticate(url, passkeyId)\n        .then((response) =>\n          resolve({\n            redirectUrl: response.redirectUrl,\n            message: response.message || undefined, // checking for empty string from native bridge\n          })\n        )\n        .catch(reject);\n    });\n  },\n  bindPasskey: function (url: string): Promise<BindPasskeyResponse> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.bindPasskey(url)\n        .then((response) =>\n          resolve({\n            passkey: response.passkey,\n            postBindingRedirectUri:\n              response.postBindingRedirectUri || undefined, // checking for empty string from native bridge\n          })\n        )\n        .catch(reject);\n    });\n  },\n  deletePasskey: function (id: string): Promise<string> {\n    return EmbeddedNativeModules.deletePasskey(id);\n  },\n  getPasskeys: function (): Promise<Passkey[]> {\n    return EmbeddedNativeModules.getPasskeys();\n  },\n  initialize: function (\n    biometricAskPrompt: string,\n    allowedDomains: string[] = []\n  ): Promise<Success> {\n    return EmbeddedNativeModules.initialize(allowedDomains, biometricAskPrompt);\n  },\n  isAuthenticateUrl(url: string): Promise<boolean> {\n    return EmbeddedNativeModules.isAuthenticateUrl(url);\n  },\n  isBindPasskeyUrl(url: string): Promise<boolean> {\n    return EmbeddedNativeModules.isBindPasskeyUrl(url);\n  },\n  logEventEmitter: LoggerEventEmitter,\n};\n\nexport { AuthenticateResponse, Passkey, PasskeyState, Embedded, Success };\n"],"mappings":"AAAA,SACEA,qBAAqB,EACrBC,kBAAkB,QAEb,yBAAyB;AAiEhC,MAAMC,QAAkB,GAAG;EACzBC,YAAY,CAACC,GAAW,EAAEC,SAAiB,EAAiC;IAC1E,OAAO,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;MAC5CR,qBAAqB,CAACG,YAAY,CAACC,GAAG,EAAEC,SAAS,CAAC,CAC/CI,IAAI,CAAEC,QAAQ,IACbH,OAAO,CAAC;QACNI,WAAW,EAAED,QAAQ,CAACC,WAAW;QACjCC,OAAO,EAAEF,QAAQ,CAACE,OAAO,IAAIC,SAAS,CAAE;MAC1C,CAAC,CAAC,CACH,CACAC,KAAK,CAACN,MAAM,CAAC;IAClB,CAAC,CAAC;EACJ,CAAC;EACDO,WAAW,EAAE,UAAUX,GAAW,EAAgC;IAChE,OAAO,IAAIE,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;MAC5CR,qBAAqB,CAACe,WAAW,CAACX,GAAG,CAAC,CACnCK,IAAI,CAAEC,QAAQ,IACbH,OAAO,CAAC;QACNS,OAAO,EAAEN,QAAQ,CAACM,OAAO;QACzBC,sBAAsB,EACpBP,QAAQ,CAACO,sBAAsB,IAAIJ,SAAS,CAAE;MAClD,CAAC,CAAC,CACH,CACAC,KAAK,CAACN,MAAM,CAAC;IAClB,CAAC,CAAC;EACJ,CAAC;EACDU,aAAa,EAAE,UAAUC,EAAU,EAAmB;IACpD,OAAOnB,qBAAqB,CAACkB,aAAa,CAACC,EAAE,CAAC;EAChD,CAAC;EACDC,WAAW,EAAE,YAAgC;IAC3C,OAAOpB,qBAAqB,CAACoB,WAAW,EAAE;EAC5C,CAAC;EACDC,UAAU,EAAE,UACVC,kBAA0B,EAER;IAAA,IADlBC,cAAwB,uEAAG,EAAE;IAE7B,OAAOvB,qBAAqB,CAACqB,UAAU,CAACE,cAAc,EAAED,kBAAkB,CAAC;EAC7E,CAAC;EACDE,iBAAiB,CAACpB,GAAW,EAAoB;IAC/C,OAAOJ,qBAAqB,CAACwB,iBAAiB,CAACpB,GAAG,CAAC;EACrD,CAAC;EACDqB,gBAAgB,CAACrB,GAAW,EAAoB;IAC9C,OAAOJ,qBAAqB,CAACyB,gBAAgB,CAACrB,GAAG,CAAC;EACpD,CAAC;EACDsB,eAAe,EAAEzB;AACnB,CAAC;AAED,SAAsDC,QAAQ"}