{"version":3,"sources":["index.tsx"],"names":["EmbeddedNativeModules","AuthorizationCode","TokenResponse","Success","PKCE","ExtendCredentialsEvents","ExtendCredentialsEventEmitter","LoggerEventEmitter","Credential","CredentialState","Embedded","authorize","pkceCodeChallenge","scope","challenge","method","authenticate","cancelExtendCredentials","createPKCE","deleteCredential","handle","extendCredentials","handles","extendCredentialsEventEmitter","getCredentials","initialize","biometricAskPrompt","clientID","redirectURI","logEventEmitter","registerCredentialsWithToken","token","registerCredentialsWithUrl","url"],"mappings":"AAAA,SACEA,qBADF,EAEEC,iBAFF,EAKEC,aALF,EAMEC,OANF,EAOEC,IAPF,EAQEC,uBARF,EASEC,6BATF,EAUEC,kBAVF,EAWEC,UAXF,EAYEC,eAZF,QAaO,yBAbP;AAeA;AACA;AACA;;AA2GA,MAAMC,QAAkB,GAAG;AACzBC,EAAAA,SAAS,EAAE,UACTC,iBADS,EAETC,KAFS,EAGmB;AAC5B,UAAMC,SAAS,GACbF,iBAAiB,CAACE,SAAlB,IAA+B,IAA/B,GAAsC,EAAtC,GAA2CF,iBAAiB,CAACE,SAD/D;AAEA,UAAMC,MAAM,GACVH,iBAAiB,CAACG,MAAlB,IAA4B,IAA5B,GAAmC,EAAnC,GAAwCH,iBAAiB,CAACG,MAD5D;AAEA,WAAOf,qBAAqB,CAACW,SAAtB,CAAgCG,SAAhC,EAA2CC,MAA3C,EAAmDF,KAAnD,CAAP;AACD,GAVwB;AAWzBG,EAAAA,YAAY,EAAE,YAAoC;AAChD,WAAOhB,qBAAqB,CAACgB,YAAtB,EAAP;AACD,GAbwB;AAczBC,EAAAA,uBAAuB,EAAE,YAA8B;AACrD,WAAOjB,qBAAqB,CAACiB,uBAAtB,EAAP;AACD,GAhBwB;AAiBzBC,EAAAA,UAAU,EAAE,YAA2B;AACrC,WAAOlB,qBAAqB,CAACkB,UAAtB,EAAP;AACD,GAnBwB;AAoBzBC,EAAAA,gBAAgB,EAAE,UAAUC,MAAV,EAA2C;AAC3D,WAAOpB,qBAAqB,CAACmB,gBAAtB,CAAuCC,MAAvC,CAAP;AACD,GAtBwB;AAuBzBC,EAAAA,iBAAiB,EAAE,UAAUC,OAAV,EAAmC;AACpD,WAAOtB,qBAAqB,CAACqB,iBAAtB,CAAwCC,OAAxC,CAAP;AACD,GAzBwB;AA0BzBC,EAAAA,6BAA6B,EAAEjB,6BA1BN;AA2BzBkB,EAAAA,cAAc,EAAE,YAAmC;AACjD,WAAOxB,qBAAqB,CAACwB,cAAtB,EAAP;AACD,GA7BwB;AA8BzBC,EAAAA,UAAU,EAAE,UACVC,kBADU,EAEVC,QAFU,EAGVC,WAHU,EAIJ;AACN,WAAO5B,qBAAqB,CAACyB,UAAtB,CACLC,kBADK,EAELC,QAFK,EAGLC,WAHK,CAAP;AAKD,GAxCwB;AAyCzBC,EAAAA,eAAe,EAAEtB,kBAzCQ;AA0CzBuB,EAAAA,4BAA4B,EAAE,UAC5BC,KAD4B,EAEL;AACvB,WAAO/B,qBAAqB,CAAC8B,4BAAtB,CAAmDC,KAAnD,CAAP;AACD,GA9CwB;AA+CzBC,EAAAA,0BAA0B,EAAE,UAAUC,GAAV,EAA4C;AACtE,WAAOjC,qBAAqB,CAACgC,0BAAtB,CAAiDC,GAAjD,CAAP;AACD;AAjDwB,CAA3B;AAoDA,SACEhC,iBADF,EAEEO,UAFF,EAGEC,eAHF,EAIEC,QAJF,EAKEL,uBALF,EAMED,IANF,EAQED,OARF,EASED,aATF","sourcesContent":["import {\n  EmbeddedNativeModules,\n  AuthorizationCode,\n  BIEventEmitter,\n  BILoggerEmitter,\n  TokenResponse,\n  Success,\n  PKCE,\n  ExtendCredentialsEvents,\n  ExtendCredentialsEventEmitter,\n  LoggerEventEmitter,\n  Credential,\n  CredentialState,\n} from './EmbeddedNativeModules';\n\n/**\n * PKCE `codeChallenege` derived from a `codeVerifier`. Send this to the authorization request, to be verified against later.\n */\ntype PKCEChallenge =\n  | {\n      challenge?: never;\n      method?: never;\n    }\n  | {\n      challenge: string;\n      method: string;\n    };\ninterface Embedded {\n  /**\n   * Used for OIDC confidential clients.\n   * Authorize a user from a confidential client and receive an `AuthorizationCode` to be used by your backend for a token exchange.\n   * This assumes the existing of a secure backend that can safely store the client secret and can exchange the authorization code for an access and id token.\n   * Make sure you have configured your clientID to be a confidential client ID.\n   * @param pkceCodeChallenge Optional PKCE challenge and method. Recommended to prevent authorization code injection.\n   * @param scope string list (comma separated) of OIDC scopes used during authentication to authorize access to a user's specific details. Only \"openid\" is currently supported.\n   */\n  authorize(\n    pkceCodeChallenge: PKCEChallenge,\n    scopes: string\n  ): Promise<AuthorizationCode>;\n\n  /**\n   * Used for OIDC public clients.\n   * Authentiate a user from a public client and receive a `TokenResponse`. The will contain the access and id token.\n   * PKCE is handled internally to mitigate against an authorization code interception attack.\n   * This assumes there is no backend and the client secret can't be safely stored.\n   * Make sure you have configured your clientID to be a public client ID.\n   */\n  authenticate(): Promise<TokenResponse>;\n\n  /**\n   * Cancel an in progress `extendCredentials`.\n   * This is called implicitly if an `extendCredentials` succeeds or fails.\n   * Alternatively, this needs to be called if a user no longer needs to extend a Credential.\n   */\n  cancelExtendCredentials(): Promise<Success>;\n\n  /**\n   * Create a Proof Key for Code Exchange (PKCE, pronounced \"pixy\")\n   * Used by public clients to mitigate authorization code interception attack.\n   * {@link https://datatracker.ietf.org/doc/html/rfc7636}\n   */\n  createPKCE(): Promise<PKCE>;\n\n  /**\n   * Delete a Credential by handle.\n   * @warning deleting a Credential is destructive and will remove everything from the device. If no other device contains the credential then the user will need to complete a recovery in order to log in again on this device.\n   * @param handle string handle that uniquely identifies a `Credential`.\n   */\n  deleteCredential(handle: string): Promise<string>;\n\n  /**\n   * Extend a list of credentials. The user must be in an authenticated state to extend any credentials.\n   * Use this function to extend credentials from one device to another.\n   * Calling this function will emit `ExtendCredentialsEvents` that should be listened for through `extendCredentialsEventEmitter`.\n   * Only one credential per device is currently supported.\n   * @param handles list of Credential handles to be extended\n   */\n  extendCredentials(handles: string[]): void;\n\n  /**\n   * A NativeEventEmitter to listen for `ExtendCredentialsEvents` events after calling `Embedded.extendCredentials`\n   */\n  extendCredentialsEventEmitter: BIEventEmitter;\n\n  /**\n   * Get all current credentials.\n   * Only one credential per device is currently supported.\n   */\n  getCredentials(): Promise<Credential[]>;\n\n  /**\n   * Register a Credential.\n   * Use this function to register a Credential from one device to another.\n   * @param token the 9 digit code that the user entered. This may represent one or more credentials, but only one credential per device is currently supported.\n   */\n  registerCredentialsWithToken(token: string): Promise<Credential[]>;\n\n  /**\n   * Initialize the SDK. This must be called before any other functions are called.\n   * @param biometricAskPrompt A prompt the user will see when asked for biometrics while extending a credential to another device.\n   * @param clientID The public or confidential client ID generated during the OIDC configuration.\n   * @param redirectURI URI where the user will be redirected after the authorization has completed.\n   * The redirect URI must be one of the URIs passed in the OIDC configuration.\n   */\n  initialize(\n    biometricAskPrompt: string,\n    clientID: string,\n    redirectURI: string\n  ): void;\n\n  /**\n   * A NativeEventEmitter to listen for `Logger` events after calling `Embedded.initialize`\n   */\n  logEventEmitter: BILoggerEmitter;\n\n  /**\n   * Use this function to handle a universal link passed to the app during registration or recovery.\n   * The url might be passed after a user taps a registration or recovery email.\n   * @param url a universal link passed to the app during registration or recovery.\n   */\n  registerCredentialsWithUrl(url: string): Promise<Credential>;\n}\n\nconst Embedded: Embedded = {\n  authorize: function (\n    pkceCodeChallenge: PKCEChallenge,\n    scope: string\n  ): Promise<AuthorizationCode> {\n    const challenge =\n      pkceCodeChallenge.challenge == null ? '' : pkceCodeChallenge.challenge;\n    const method =\n      pkceCodeChallenge.method == null ? '' : pkceCodeChallenge.method;\n    return EmbeddedNativeModules.authorize(challenge, method, scope);\n  },\n  authenticate: function (): Promise<TokenResponse> {\n    return EmbeddedNativeModules.authenticate();\n  },\n  cancelExtendCredentials: function (): Promise<Success> {\n    return EmbeddedNativeModules.cancelExtendCredentials();\n  },\n  createPKCE: function (): Promise<PKCE> {\n    return EmbeddedNativeModules.createPKCE();\n  },\n  deleteCredential: function (handle: string): Promise<string> {\n    return EmbeddedNativeModules.deleteCredential(handle);\n  },\n  extendCredentials: function (handles: string[]): void {\n    return EmbeddedNativeModules.extendCredentials(handles);\n  },\n  extendCredentialsEventEmitter: ExtendCredentialsEventEmitter,\n  getCredentials: function (): Promise<Credential[]> {\n    return EmbeddedNativeModules.getCredentials();\n  },\n  initialize: function (\n    biometricAskPrompt: string,\n    clientID: string,\n    redirectURI: string\n  ): void {\n    return EmbeddedNativeModules.initialize(\n      biometricAskPrompt,\n      clientID,\n      redirectURI\n    );\n  },\n  logEventEmitter: LoggerEventEmitter,\n  registerCredentialsWithToken: function (\n    token: string\n  ): Promise<Credential[]> {\n    return EmbeddedNativeModules.registerCredentialsWithToken(token);\n  },\n  registerCredentialsWithUrl: function (url: string): Promise<Credential> {\n    return EmbeddedNativeModules.registerCredentialsWithUrl(url);\n  },\n};\n\nexport {\n  AuthorizationCode,\n  Credential,\n  CredentialState,\n  Embedded,\n  ExtendCredentialsEvents,\n  PKCE,\n  PKCEChallenge,\n  Success,\n  TokenResponse,\n};\n"]}